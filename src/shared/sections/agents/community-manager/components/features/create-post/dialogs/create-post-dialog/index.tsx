'use client';

import React, { useState, useEffect, useRef } from 'react';
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Box,
  useTheme,
  Divider,
  IconButton,
  Tooltip,
} from '@mui/material';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { AdapterDayjs } from '@mui/x-date-pickers/AdapterDayjs';
import dayjs, { Dayjs } from 'dayjs';
import 'dayjs/locale/fr';
import { FontAwesomeIcon } from '@/shared/components/fontawesome';
import { ScheduledPost, PostStatus } from '@/shared/types/calendar';
import { ManualModeForm } from '../../components/manual-mode/manual-mode-form';
import { AutomaticModeEditing } from '../../components/automatic-mode/automatic-mode-editing';
import { AutomaticModeGeneration } from '../../components/automatic-mode/automatic-mode-generation';
import { PublishDateSection } from '../../components/publish-date-section';
import { DialogActionsSection } from './dialog-actions-section';
import { DeletePostDialog } from '../delete-post-dialog';
import { DeleteImageDialog } from '../delete-image-dialog';
import { StatusChip } from '../../components/status-chip';
import { ModeSelector } from '../../components/mode-selector';
import { CaptionSection } from '../../components/caption-section';
import { PlatformSelection } from '../../components/platform-selection';
import { styles } from './create-post-dialog.styles';

type PostMode = 'manual' | 'automatic';
interface AutoGeneratedContent {
  caption: string;
  imageUrls: string[];
  platforms: string[];
  generatedAt: string;
}

export interface CreatePostDialogProps {
  open: boolean;
  selectedDate?: Date | null;
  currentPost?: Partial<ScheduledPost> | null;
  onClose: () => void;
  onSubmit: (data: {

    mode: PostMode;
    // Mode manuel
    mediaFiles?: File[];
    imageUrls?: string[];
    caption?: string;
    selectedPlatforms?: string[];
    publishDate?: Dayjs | null;
    publishTime?: Dayjs | null;
    channels?: string[];
    imageCount?: number;
    imagePrompts?: { [key: number]: string };
    inspirationUrl?: string;
    description?: string;
    generatedCaption?: string;
    generatedImageUrls?: string[];
    generatedPlatforms?: string[];
    saveAsDraft?: boolean;
    forceStatus?: PostStatus;
  }) => void;
  onDelete?: (postId: string) => void;
}

export const CreatePostDialog: React.FC<CreatePostDialogProps> = ({
  open,
  selectedDate,
  currentPost,
  onClose,
  onSubmit,
  onDelete,
}) => {
  const theme = useTheme();
  const [mode, setMode] = useState<PostMode>('manual');
  const [mediaFiles, setMediaFiles] = useState<File[]>([]);
  const [imageUrls, setImageUrls] = useState<string[]>([]);
  const [currentImageIndex, setCurrentImageIndex] = useState(0);
  const [isDragging, setIsDragging] = useState(false);
  const [deleteImageIndex, setDeleteImageIndex] = useState<number | null>(null);
  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);
  const [caption, setCaption] = useState('');
  const [selectedPlatforms, setSelectedPlatforms] = useState<string[]>([]);
  const [publishDate, setPublishDate] = useState<Dayjs | null>(null);
  const [publishTime, setPublishTime] = useState<Dayjs | null>(null);
  
  const [channels, setChannels] = useState<string[]>([]);
  const [imageCount, setImageCount] = useState<number>(1);
  const [imagePrompts, setImagePrompts] = useState<{ [key: number]: string }>({});
  const [inspirationUrl, setInspirationUrl] = useState('');
  const [description, setDescription] = useState('');
  const [referenceImages, setReferenceImages] = useState<{ [key: number]: { file: File | null; url: string } }>({});
  const [autoGeneratedContent, setAutoGeneratedContent] = useState<AutoGeneratedContent | null>(null);
  const [isGeneratingAutoContent, setIsGeneratingAutoContent] = useState(false);
  const [autoStep, setAutoStep] = useState<'generation' | 'editing'>('generation');
  const imagePromptsSignature = JSON.stringify(imagePrompts);

  const fileInputRef = useRef<HTMLInputElement>(null);
  const fileInputRefs = useRef<(HTMLInputElement | null)[]>([]);
  const autoPreviewDepsRef = useRef<string>('');

  useEffect(() => {
    if (open) {
      if (currentPost?.id) {
        const startDate = currentPost.start ? dayjs(currentPost.start) : dayjs();
        const dateOnly = dayjs()
          .year(startDate.year())
          .month(startDate.month())
          .date(startDate.date())
          .hour(0)
          .minute(0)
          .second(0)
          .millisecond(0);
        setPublishDate(dateOnly);
        const timeOnly = dayjs()
          .hour(startDate.hour())
          .minute(startDate.minute())
          .second(0)
          .millisecond(0);
        setPublishTime(timeOnly);
        setSelectedPlatforms(currentPost.platformIds ?? []);
        setCaption(currentPost.caption || '');
        setMode('manual');
        if (currentPost.imageUrls && currentPost.imageUrls.length > 0) {
          setImageUrls([...currentPost.imageUrls]);
          setCurrentImageIndex(0);
        } else {
          setImageUrls([]);
          setCurrentImageIndex(0);
        }
        setMediaFiles([]);
        setChannels([]);
        setInspirationUrl('');
        setDescription('');
        setImageCount(1);
        setImagePrompts({});
        setReferenceImages({});
        setAutoGeneratedContent(null);
        setIsGeneratingAutoContent(false);
        setAutoStep('generation');
      } else {
        const today = selectedDate ? dayjs(selectedDate) : dayjs();
        setPublishDate(today);
        setPublishTime(today.add(1, 'hour'));
        setSelectedPlatforms([]);
        setChannels([]);
        setMode('manual');
        setMediaFiles([]);
        setImageUrls([]);
        setCurrentImageIndex(0);
        setCaption('');
        setInspirationUrl('');
        setDescription('');
        setImageCount(1);
        setImagePrompts({});
        setReferenceImages({});
        setAutoGeneratedContent(null);
        setIsGeneratingAutoContent(false);
        setAutoStep('generation');
      }
    }
  }, [open, selectedDate, currentPost]);

  useEffect(() => {
    if (open) {
      const fontFamily = theme.typography.fontFamily || 'inherit';
      const style = document.createElement('style');
      style.id = 'create-post-dialog-calendar-styles';
      style.textContent = styles.getCalendarStyles(fontFamily);
      document.head.appendChild(style);

      return () => {
        const existingStyle = document.getElementById('create-post-dialog-calendar-styles');
        if (existingStyle) {
          document.head.removeChild(existingStyle);
        }
      };
    }
  }, [open, theme]);

  useEffect(() => {
    if (!open) {
      setAutoGeneratedContent(null);
      setIsGeneratingAutoContent(false);
    }
  }, [open]);

  useEffect(() => {
    const depsKey = [
      channels.join(','),
      imageCount,
      inspirationUrl,
      description,
      imagePromptsSignature,
    ].join('|');

    if (!autoGeneratedContent) {
      autoPreviewDepsRef.current = depsKey;
      return;
    }

    if (autoPreviewDepsRef.current && autoPreviewDepsRef.current !== depsKey) {
      setAutoGeneratedContent(null);
    }

    autoPreviewDepsRef.current = depsKey;
  }, [channels, imageCount, inspirationUrl, description, imagePromptsSignature, autoGeneratedContent]);

  const handleModeChange = (newMode: PostMode) => {
    setMode(newMode);
    if (newMode === 'manual') {
      setChannels([]);
    }
    setAutoGeneratedContent(null);
    setIsGeneratingAutoContent(false);
    setAutoStep('generation');
  };

  const handleReferenceImageUpload = (index: number, event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (file) {
      const reader = new FileReader();
      reader.onloadend = () => {
        setReferenceImages(prev => ({
          ...prev,
          [index]: { file, url: reader.result as string }
        }));
      };
      reader.readAsDataURL(file);
    }
  };

  const handleRemoveReferenceImage = (index: number) => {
    setReferenceImages(prev => {
      const newImages = { ...prev };
      delete newImages[index];
      return newImages;
    });
  };

  const handleRegenerate = () => {
    setAutoStep('generation');
    setImageUrls([]);
    setCurrentImageIndex(0);
    setCaption('');
    setSelectedPlatforms([]);
  };

  const handleGenerateAutomaticPreview = () => {
    if (channels.length === 0) {
      alert('Veuillez sélectionner au moins une plateforme à générer.');
      return;
    }

    if (imageCount < 1) {
      alert('Veuillez préciser le nombre d’images à générer.');
      return;
    }

    if (!description || description.trim().length === 0) {
      alert('Veuillez décrire votre post pour guider l’IA.');
      return;
    }

    setIsGeneratingAutoContent(true);

    setTimeout(() => {
      const generatedImages = Array.from({ length: imageCount }, (_, index) => {
        const seed = `${Date.now()}-${index}`;
        return `https://picsum.photos/seed/${seed}/640/360`;
      });

      const generatedCaption =
        description.trim().length > 0
          ? description.trim()
          : `Post généré automatiquement - ${dayjs().format('DD MMMM HH:mm')}`;

      setAutoGeneratedContent({
        caption: generatedCaption,
        imageUrls: generatedImages,
        platforms: [...channels],
        generatedAt: dayjs().format('HH:mm'),
      });

      setImageUrls(generatedImages);
      setCurrentImageIndex(0);
      setCaption(generatedCaption);
      setSelectedPlatforms([...channels]);
      setAutoStep('editing');
      setIsGeneratingAutoContent(false);
    }, 1400);
  };

  const handleFileSelect = (event: React.ChangeEvent<HTMLInputElement>) => {
    const files = Array.from(event.target.files || []);
    files.forEach((file) => {
      const reader = new FileReader();
      reader.onloadend = () => {
        setImageUrls((prev) => {
          const newUrls = [...prev, reader.result as string];
          setCurrentImageIndex(newUrls.length - 1);
          return newUrls;
        });
        setMediaFiles((prev) => [...prev, file]);
      };
      reader.readAsDataURL(file);
    });
  };

  const handleRemoveImage = (index: number) => {
    setDeleteImageIndex(index);
  };

  const handleConfirmRemoveImage = () => {
    if (deleteImageIndex !== null) {
      const newImageUrls = imageUrls.filter((_, i) => i !== deleteImageIndex);
      const newMediaFiles = mediaFiles.filter((_, i) => i !== deleteImageIndex);
      setImageUrls(newImageUrls);
      setMediaFiles(newMediaFiles);

      if (currentImageIndex >= newImageUrls.length) {
        setCurrentImageIndex(Math.max(0, newImageUrls.length - 1));
      } else if (currentImageIndex > deleteImageIndex) {
        setCurrentImageIndex(currentImageIndex - 1);
      }

      setDeleteImageIndex(null);
    }
  };

  const handleCancelRemoveImage = () => {
    setDeleteImageIndex(null);
  };

  const handleDragEnd = (result: any) => {
    setIsDragging(false);
    if (!result.destination) return;

    const items = Array.from(imageUrls);
    const files = Array.from(mediaFiles);
    const [reorderedItem] = items.splice(result.source.index, 1);
    const [reorderedFile] = files.splice(result.source.index, 1);
    items.splice(result.destination.index, 0, reorderedItem);
    files.splice(result.destination.index, 0, reorderedFile);

    setImageUrls(items);
    setMediaFiles(files);

    if (currentImageIndex === result.source.index) {
      setCurrentImageIndex(result.destination.index);
    } else if (
      currentImageIndex > result.source.index &&
      currentImageIndex <= result.destination.index
    ) {
      setCurrentImageIndex(currentImageIndex - 1);
    } else if (
      currentImageIndex < result.source.index &&
      currentImageIndex >= result.destination.index
    ) {
      setCurrentImageIndex(currentImageIndex + 1);
    }
  };

  const handlePreviousImage = (e: React.MouseEvent) => {
    e.stopPropagation();
    if (currentImageIndex > 0) {
      setCurrentImageIndex((prev) => prev - 1);
    }
  };

  const handleNextImage = (e: React.MouseEvent) => {
    e.stopPropagation();
    if (currentImageIndex < imageUrls.length - 1) {
      setCurrentImageIndex((prev) => prev + 1);
    }
  };

  const handleReplaceImage = (index: number, file: File) => {
    const reader = new FileReader();
    reader.onloadend = () => {
      const newUrls = [...imageUrls];
      newUrls[index] = reader.result as string;
      setImageUrls(newUrls);
      const newFiles = [...mediaFiles];
      newFiles[index] = file;
      setMediaFiles(newFiles);
    };
    reader.readAsDataURL(file);
  };

  const handleAddImageFromGallery = (imageUrl: string) => {
    setImageUrls((prev) => {
      const newUrls = [...prev, imageUrl];
      setCurrentImageIndex(newUrls.length - 1);
      return newUrls;
    });
  };

  const handleReplaceImageFromGallery = (index: number, imageUrl: string) => {
    const newUrls = [...imageUrls];
    newUrls[index] = imageUrl;
    setImageUrls(newUrls);
  };

  const handleAddImage = () => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*,video/*';
    input.multiple = true;
    input.onchange = (e: any) => handleFileSelect(e);
    input.click();
  };

  const canGoPrevious = currentImageIndex > 0;
  const canGoNext = currentImageIndex < imageUrls.length - 1;

  const handlePlatformToggle = (platformId: string) => {
    setSelectedPlatforms((prev) =>
      prev.includes(platformId)
        ? prev.filter((id) => id !== platformId)
        : [...prev, platformId]
    );
  };

  const handleChannelToggle = (channelId: string) => {
    setChannels((prev) =>
      prev.includes(channelId)
        ? prev.filter((id) => id !== channelId)
        : [...prev, channelId]
    );
  };

  const handleAutoGenerateCaption = () => {
    alert('Fonctionnalité d\'auto-génération de légende à implémenter');
  };

  const handleSubmit = ({
    saveAsDraft = false,
    forceStatus,
  }: { saveAsDraft?: boolean; forceStatus?: PostStatus } = {}) => {
    if (mode === 'automatic' && !currentPost?.id && !saveAsDraft && !autoGeneratedContent) {
      alert('Veuillez d’abord générer un aperçu avec l’IA avant de planifier.');
      return;
    }

    if (forceStatus === 'scheduled' && (!publishDate || !publishTime)) {
      alert('Veuillez sélectionner une date et une heure avant de planifier.');
      return;
    }

    if (currentPost?.id) {
      onSubmit({
        mode: 'manual',
        mediaFiles,
        imageUrls,
        caption,
        selectedPlatforms,
        publishDate,
        publishTime,
        forceStatus,
        saveAsDraft: false,
      });
      return;
    }

    if (mode === 'manual') {
      if (!saveAsDraft && (selectedPlatforms.length === 0 || !publishDate || !publishTime)) {
        alert('Veuillez remplir tous les champs requis');
        return;
      }
      onSubmit({
        mode: 'manual',
        mediaFiles,
        caption,
        selectedPlatforms,
        publishDate,
        publishTime,
        saveAsDraft,
      });
    } else {
      if (!saveAsDraft && (channels.length === 0 || !publishDate || !publishTime)) {
        alert('Veuillez remplir tous les champs requis');
        return;
      }
      onSubmit({
        mode: 'automatic',
        channels,
        imageCount,
        imagePrompts,
        inspirationUrl,
        description,
        publishDate,
        publishTime,
        saveAsDraft,
        generatedCaption: autoGeneratedContent?.caption,
        generatedImageUrls: autoGeneratedContent?.imageUrls,
        generatedPlatforms: autoGeneratedContent?.platforms,
      });
    }
  };


  const renderManualMode = () => (
    <ManualModeForm
      imageUrls={imageUrls}
      currentImageIndex={currentImageIndex}
      onImageSelect={setCurrentImageIndex}
      onRemoveImage={handleRemoveImage}
      onAddImage={handleAddImage}
      onPreviousImage={handlePreviousImage}
      onNextImage={handleNextImage}
      onReplaceImage={handleReplaceImage}
      onDragEnd={handleDragEnd}
      onDragStart={() => setIsDragging(true)}
      fileInputRef={fileInputRef}
      fileInputRefs={fileInputRefs}
      canGoPrevious={canGoPrevious}
      canGoNext={canGoNext}
      caption={caption}
      onCaptionChange={setCaption}
      onAutoGenerateCaption={handleAutoGenerateCaption}
      selectedPlatforms={selectedPlatforms}
      onPlatformToggle={handlePlatformToggle}
      onFileSelect={handleFileSelect}
      onAddImageFromGallery={handleAddImageFromGallery}
      onReplaceImageFromGallery={handleReplaceImageFromGallery}
    />
  );

  const renderAutomaticMode = () => {
    if (autoStep === 'editing') {
      return (
        <AutomaticModeEditing
          imageUrls={imageUrls}
          currentImageIndex={currentImageIndex}
          onImageSelect={setCurrentImageIndex}
          onRemoveImage={handleRemoveImage}
          onAddImage={handleAddImage}
          onPreviousImage={handlePreviousImage}
          onNextImage={handleNextImage}
          onReplaceImage={handleReplaceImage}
          onDragEnd={handleDragEnd}
          onDragStart={() => setIsDragging(true)}
          fileInputRef={fileInputRef}
          fileInputRefs={fileInputRefs}
          canGoPrevious={canGoPrevious}
          canGoNext={canGoNext}
          caption={caption}
          onCaptionChange={setCaption}
          onAutoGenerateCaption={handleAutoGenerateCaption}
          selectedPlatforms={selectedPlatforms}
          onPlatformToggle={handlePlatformToggle}
          onFileSelect={handleFileSelect}
          onRegenerate={handleRegenerate}
          onAddImageFromGallery={handleAddImageFromGallery}
          onReplaceImageFromGallery={handleReplaceImageFromGallery}
        />
      );
    }

    return (
      <AutomaticModeGeneration
        channels={channels}
        onChannelToggle={handleChannelToggle}
        imageCount={imageCount}
        onImageCountChange={(value) => {
          setImageCount(value);
          const newPrompts: { [key: number]: string } = {};
          for (let i = 0; i < value; i++) {
            if (imagePrompts[i]) {
              newPrompts[i] = imagePrompts[i];
            }
          }
          setImagePrompts(newPrompts);
        }}
        imagePrompts={imagePrompts}
        onImagePromptChange={(index, prompt) => {
          setImagePrompts((prev) => ({
            ...prev,
            [index]: prompt,
          }));
        }}
        referenceImages={referenceImages}
        onReferenceImageUpload={handleReferenceImageUpload}
        onRemoveReferenceImage={handleRemoveReferenceImage}
        inspirationUrl={inspirationUrl}
        onInspirationUrlChange={setInspirationUrl}
        description={description}
        onDescriptionChange={setDescription}
      />
    );
  };

  return (
    <LocalizationProvider dateAdapter={AdapterDayjs} adapterLocale="fr">
      <Dialog
        open={open}
        onClose={onClose}
        maxWidth="md"
        fullWidth
        PaperProps={{ sx: styles.dialogPaper }}
        sx={styles.dialogBackdrop}
      >
        <DialogTitle sx={styles.dialogTitle(theme)}>
          {currentPost?.id ? 'Modifier un post' : 'Créer un post'}
        </DialogTitle>
        <DialogContent>
          {currentPost?.id && currentPost.status && (
            <StatusChip status={currentPost.status} />
          )}

          {!currentPost?.id && (
            <ModeSelector mode={mode} onModeChange={handleModeChange} />
          )}

          <Divider sx={{ my: 3, borderColor: 'rgba(255, 255, 255, 0.1)' }} />

          {mode === 'manual' ? renderManualMode() : renderAutomaticMode()}

          {(mode === 'manual' || (mode === 'automatic' && autoStep === 'editing')) && (
            <PublishDateSection
              publishDate={publishDate}
              publishTime={publishTime}
              onPublishDateChange={setPublishDate}
              onPublishTimeChange={setPublishTime}
            />
          )}
        </DialogContent>
        <DialogActions sx={{ p: 3, gap: 1.5, flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center' }}>
          {currentPost?.id && onDelete ? (
            <Tooltip title="Supprimer le post" arrow>
              <IconButton
                onClick={() => setShowDeleteConfirm(true)}
                sx={{
                  color: '#E04343',
                  '&:hover': {
                    backgroundColor: 'rgba(224, 67, 67, 0.1)',
                  },
                }}
              >
                <FontAwesomeIcon icon="trash" style={{ fontSize: '18px' }} />
              </IconButton>
            </Tooltip>
          ) : (
            <Box />
          )}

          <DialogActionsSection
            currentPostId={currentPost?.id}
            currentPostStatus={currentPost?.status}
            mode={mode}
            autoStep={autoStep}
            isGeneratingAutoContent={isGeneratingAutoContent}
            onClose={onClose}
            onDelete={currentPost?.id && onDelete ? () => {
              if (currentPost.id) {
                onDelete(currentPost.id);
                setShowDeleteConfirm(false);
                onClose();
              }
            } : undefined}
            onGenerateAutomaticPreview={handleGenerateAutomaticPreview}
            onSubmit={handleSubmit}
          />
        </DialogActions>
      </Dialog>

      <DeletePostDialog
        open={showDeleteConfirm}
        onClose={() => setShowDeleteConfirm(false)}
        onConfirm={() => {
          if (currentPost?.id && onDelete) {
            onDelete(currentPost.id);
            setShowDeleteConfirm(false);
            onClose();
          }
        }}
      />

      <DeleteImageDialog
        open={deleteImageIndex !== null}
        onClose={handleCancelRemoveImage}
        onConfirm={handleConfirmRemoveImage}
      />
    </LocalizationProvider>
  );
};

